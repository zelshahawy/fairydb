use crate::ids::{ColumnId, ContainerId};
use crate::table::TableInfo;
use crate::{table::TableSchema, MAX_COLUMNS};
use serde::Serialize;
use std::collections::HashMap;
use std::sync::{Arc, Mutex, RwLock};

/// Generates temporary column ID based on table index and column index.
/// Note that this temporary column ID is only used for sequential scans.
/// The reason why we are using the unique column ID generated by ColIdGenerator
/// instead of this temporary column ID is that in case of self-joins, we need
/// to have unique column IDs for each column in the table.
/// Note that this function assumes that a table cannot have more than `MAX_COLUMNS`
/// (100) columns.
fn get_temp_col_id(table_index: ContainerId, column_index: usize) -> ColumnId {
    table_index as ColumnId * MAX_COLUMNS + column_index as ColumnId
}

/// Returns the table index from the temporary column ID.
/// Note that this temporary column ID is typically only used for sequential scans
/// because afterwards the `rename` operator will map the temporary column ID to
/// the unique column ID generated by ColIdGenerator.
pub fn get_table_index_from_temp_col_id(col_id: ColumnId) -> ContainerId {
    (col_id / MAX_COLUMNS) as ContainerId
}

/// Returns the column index from the temporary column ID.
/// Note that this temporary column ID is typically only used for sequential scans
/// because afterwards the `rename` operator will map the temporary column ID to
/// the unique column ID generated by ColIdGenerator.
pub fn get_column_index_from_temp_col_id(col_id: ColumnId) -> ColumnId {
    (col_id % MAX_COLUMNS) as ColumnId
}

// Reference: https://github.com/rotaki/decorrelator
#[derive(Serialize, Deserialize, Debug)]
struct ContainerIdGenerator {
    next_id: ContainerId,
    table_to_id: HashMap<String, ContainerId>,
}

impl ContainerIdGenerator {
    fn new() -> Self {
        ContainerIdGenerator {
            next_id: 0,
            table_to_id: HashMap::new(),
        }
    }

    /// Note that ContainerId is not unique across multiple databases.
    /// Note that if table_name is not found, it will generate a new ContainerId.
    /// Note the difference between `get_table_id` and `get_table_id_if_exists`.
    fn get_table_id(&mut self, table_name: &str) -> ContainerId {
        match self.table_to_id.get(table_name) {
            Some(c_id) => *c_id,
            None => {
                let c_id = self.next_id;
                self.next_id += 1;
                self.table_to_id.insert(table_name.to_string(), c_id);
                c_id
            }
        }
    }

    /// Returns the table index if the table exists. Note the difference between
    /// `get_table_id` and `get_table_id_if_exists` is that the former will generate
    /// a new table index if the table does not exist, while the latter will return
    /// `None` if the table does not exist.
    fn get_table_id_if_exists(&self, table_name: &str) -> Option<ContainerId> {
        self.table_to_id.get(table_name).cloned()
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Catalog {
    container_id_generator: Mutex<ContainerIdGenerator>,
    tables: RwLock<HashMap<ContainerId, TableInfo>>,
}

impl Catalog {
    pub fn new() -> CatalogRef {
        Arc::new(Catalog {
            container_id_generator: Mutex::new(ContainerIdGenerator::new()),
            tables: RwLock::new(HashMap::new()),
        })
    }

    /// Returns the table index for the given table name. If the table does not exist,
    /// it will generate a new table index.
    /// Note the difference between `get_table_id` and `get_table_id_if_exists`
    pub fn get_table_id(&self, name: &str) -> ContainerId {
        let mut generator = self.container_id_generator.lock().unwrap();
        generator.get_table_id(name)
    }

    pub fn add_table(&self, table_info: TableInfo) -> Option<()> {
        let mut tables = self.tables.write().unwrap();
        match tables.get(&table_info.c_id) {
            Some(_) => None,
            None => {
                let cid = table_info.c_id;
                tables.insert(cid, table_info);
                Some(())
            }
        }
    }

    pub fn get_table(&self, c_id: ContainerId) -> Option<TableInfo> {
        let tables = self.tables.read().unwrap();
        tables.get(&c_id).cloned()
    }

    pub fn get_table_names(&self) -> Vec<String> {
        let tables = self.tables.read().unwrap();
        tables.values().map(|info| info.name.clone()).collect()
    }

    pub fn get_table_schema(&self, c_id: ContainerId) -> Option<TableSchema> {
        let tables = self.tables.read().unwrap();
        tables.get(&c_id).map(|info| info.schema.clone())
    }

    pub fn is_valid_table(&self, c_id: ContainerId) -> bool {
        let tables = self.tables.read().unwrap();
        tables.contains_key(&c_id)
    }

    /// Returns the table index if the table exists. Note the difference between
    /// `get_table_id` and `get_table_id_if_exists` is that the former will generate
    /// a new table index if the table does not exist, while the latter will return
    /// `None` if the table does not exist.
    pub fn get_table_id_if_exists(&self, table_name: &str) -> Option<ContainerId> {
        let generator = self.container_id_generator.lock().unwrap();
        generator.get_table_id_if_exists(table_name)
    }

    /// Given a table name, returns whether the table exists in the catalog.
    pub fn is_valid_table_from_string(&self, table_name: &str) -> bool {
        self.get_table_id_if_exists(table_name).is_some()
    }

    pub fn is_valid_column(&self, c_id: ContainerId, column_name: &str) -> bool {
        let tables = self.tables.read().unwrap();
        if let Some(table_info) = tables.get(&c_id) {
            table_info.schema.contains(column_name)
        } else {
            false
        }
    }

    /// Given a table name, return a vector of tuples containing the column name and column index.
    /// Note that the column index is calculated as `container_id * MAX_COLUMNS (100) + column_index`
    /// This column index is for temporary use only and is used for sequential scans.
    /// See the `get_temp_col_id` function for more details.
    pub fn get_cols(&self, table_name: &str) -> Vec<(String, ColumnId)> {
        // find table index
        let generator = self.container_id_generator.lock().unwrap();
        let c_id = generator.get_table_id_if_exists(table_name).unwrap();

        self.get_table_schema(c_id)
            .unwrap()
            .attributes()
            .enumerate()
            .map(|(i, attr)| (attr.name.clone(), get_temp_col_id(c_id, i)))
            .collect()
    }
}

pub type CatalogRef = Arc<Catalog>;
